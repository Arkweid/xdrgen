// Automatically generated from #{@output.source_path}
// DO NOT EDIT or your changes may be overwritten
<%
primitive = Struct.new(:name, :go_type)
primitives = [
  primitive.new("Int",    "int32"),
  primitive.new("Uint",   "uint32"),
  primitive.new("Hyper",  "int64"),
  primitive.new("Uhyper", "uint64"),
  primitive.new("Float",  "float32"),
  primitive.new("Double", "float64"),
  primitive.new("Bool",   "bool"),
]
%>

package <%= @namespace || "main" %>

import (
  "errors"
  "fmt"
  "github.com/davecgh/go-xdr/xdr2"
)

// Primitive decoders
<% primitives.each do |prim| %>
<% xdr = prim.name; go = prim.go_type %>

func Decode<%=xdr%>(decoder *xdr.Decoder, result *<%=go%>) (int, error) {
  val, bytesRead, err := decoder.Decode<%=xdr%>()

  if err == nil {
    *result = val
  }

  return bytesRead, err
}

<%= optional_decoder prim, prim.go_type %>
<%= fixed_array_decoder prim, prim.go_type %>
<%= array_decoder prim, prim.go_type %>

<% end %>

func DecodeFixedOpaque(decoder *xdr.Decoder, result []byte, size int32) (int, error) {

  if len(result) != int(size) {
    errMsg := fmt.Sprintf("xdr: bad opaque len:%d, expected %d", len(result), size)
    return 0, errors.New(errMsg)
  }

  val, bytesRead, err := decoder.DecodeFixedOpaque(size)

  if err == nil {
    copy(result, val)
  }

  return bytesRead, err
}

func DecodeOpaque(decoder *xdr.Decoder, result *[]byte, maxSize int32) (int, error) {
  val, bytesRead, err := decoder.DecodeOpaque()

  if err != nil {
    return bytesRead, err
  }

  if len(val) > int(maxSize) {
    errMsg := fmt.Sprintf("xdr: encoded opaque size too large:%d, max:%d", len(val), maxSize)
    return bytesRead, errors.New(errMsg)   
  }

  *result = val

  return bytesRead, err
}


func DecodeString(decoder *xdr.Decoder, result *string, maxSize int32) (int, error) {
  val, bytesRead, err := decoder.DecodeString()

  if err != nil {
    return bytesRead, err
  }

  if len(val) > int(maxSize) {
    errMsg := fmt.Sprintf("xdr: encoded string size too large:%d, max:%d", len(val), maxSize)
    return bytesRead, errors.New(errMsg)   
  }

  *result = val

  return bytesRead, err
}