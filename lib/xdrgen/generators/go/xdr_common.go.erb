// Automatically generated from #{@output.source_path}
// DO NOT EDIT or your changes may be overwritten
<%
primitive = Struct.new(:name, :go_type)
primitives = [
  primitive.new("Int",    "int32"),
  primitive.new("Uint",   "uint32"),
  primitive.new("Hyper",  "int64"),
  primitive.new("Uhyper", "uint64"),
  primitive.new("Float",  "float32"),
  primitive.new("Double", "float64"),
  primitive.new("Bool",   "bool"),
]
%>

package <%= @namespace || "main" %>

import (
  "errors"
  "fmt"
  "github.com/davecgh/go-xdr/xdr2"
)

// Primitive decoders
<% primitives.each do |prim| %>
<% xdr = prim.name; go = prim.go_type %>

func Decode<%=xdr%>(decoder *xdr.Decoder, result *<%=go%>) (int, error) {
  val, bytesRead, err := decoder.Decode<%=xdr%>()

  if err == nil {
    *result = val
  }

  return bytesRead, err
}

<%= optional_decoder prim, prim.go_type %>

func Decode<%=xdr%>FixedArray(decoder *xdr.Decoder, result []<%=go%>, size int) (int, error) {
  var (
    totalRead int
    bytesRead int
    err       error
  )

  if len(result) != size {
    errMsg := fmt.Sprintf("xdr: bad array len:%d, expected %d", len(result), size)
    return 0, errors.New(errMsg)
  }

  for i := 0; i < size; i++ {
    bytesRead, err = Decode<%=xdr%>(decoder, &result[i])

    if err != nil {
      return totalRead, err
    }

    totalRead += bytesRead
  }

  return totalRead, nil
}


func Decode<%=xdr%>Array(decoder *xdr.Decoder, result *[]<%=go%>, maxSize int32) (int, error) {
  var (
    size      int32
    totalRead int
    bytesRead int
    err       error
  )

  bytesRead, err = DecodeInt(decoder, &size)
  totalRead += bytesRead

  if err != nil {
    return totalRead, err
  }

  if size > maxSize {
    errMsg := fmt.Sprintf("xdr: encoded array size too large:%d, max:%d", size, maxSize)
    return totalRead, errors.New(errMsg)
  }

  var theResult = make([]<%=go%>, size)
  *result = theResult

  for i := int32(0); i < size; i++ {
    bytesRead, err = Decode<%=xdr%>(decoder, &theResult[i])

    if err != nil {
      return totalRead, err
    }

    totalRead += bytesRead
  }

  return totalRead, nil
}

<% end %>

func DecodeFixedOpaque(decoder *xdr.Decoder, result []byte, size int32) (int, error) {

  if len(result) != int(size) {
    errMsg := fmt.Sprintf("xdr: bad opaque len:%d, expected %d", len(result), size)
    return 0, errors.New(errMsg)
  }

  val, bytesRead, err := decoder.DecodeFixedOpaque(size)

  if err == nil {
    copy(result, val)
  }

  return bytesRead, err
}

func DecodeOpaque(decoder *xdr.Decoder, result *[]byte, maxSize int32) (int, error) {
  val, bytesRead, err := decoder.DecodeOpaque()

  if err != nil {
    return bytesRead, err
  }

  if len(val) > int(maxSize) {
    errMsg := fmt.Sprintf("xdr: encoded opaque size too large:%d, max:%d", len(val), maxSize)
    return bytesRead, errors.New(errMsg)   
  }

  *result = val

  return bytesRead, err
}


func DecodeString(decoder *xdr.Decoder, result *string, maxSize int32) (int, error) {
  val, bytesRead, err := decoder.DecodeString()

  if err != nil {
    return bytesRead, err
  }

  if len(val) > int(maxSize) {
    errMsg := fmt.Sprintf("xdr: encoded string size too large:%d, max:%d", len(val), maxSize)
    return bytesRead, errors.New(errMsg)   
  }

  *result = val

  return bytesRead, err
}